@page "/filemanager"
@using DocstreamAISearch.Web.Services
@using DTO.DTOs
@inject IUploadService UploadService
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<PageTitle>File Manager</PageTitle>

<div class="container-fluid py-4">
    <!-- Header Section -->
    <div class="row mb-4">
        <div class="col-md-6">
            <h2 class="fw-bold text-dark mb-0">Archive</h2>
        </div>
        <div class="col-md-6">
            <div class="d-flex gap-2 justify-content-end align-items-center">
                <!-- Search with AI Checkbox -->
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" @bind="searchWithAI" @bind:after="OnSearchModeChanged" id="searchWithAI">
                    <label class="form-check-label" for="searchWithAI">
                        Search with AI
                    </label>
                </div>
                
                <!-- Search Input -->
                <div class="input-group" style="max-width: 300px;">
                    <input type="text" class="form-control" placeholder="Search" @bind="searchQuery" @onkeypress="OnSearchKeyPress">
                    <button class="btn btn-outline-secondary" type="button" @onclick="SearchFiles">
                        <i class="bi bi-search"></i>
                    </button>
                </div>
                
                <!-- Add New Button -->
                <button class="btn btn-primary" @onclick="OpenFileUpload">
                    Add new
                </button>
            </div>
        </div>
    </div>

    <!-- Hidden File Input -->
    <InputFile @ref="fileInput" OnChange="OnFileSelected" style="display: none;" accept=".pdf,.doc,.docx,.txt,.xlsx,.xls" id="fileUploadInput" />

    <!-- Loading State -->
    @if (isLoading)
    {
        <div class="text-center py-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Loading files...</p>
        </div>
    }
    else
    {
        <!-- Files Table -->
        <div class="row">
            <div class="col-12">
                <div class="card border-0 shadow-sm">
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-hover mb-0">
                                <thead class="table-light">
                                    <tr>
                                        <th scope="col" class="border-0 ps-4">
                                            <input type="checkbox" class="form-check-input" @onchange="ToggleSelectAll">
                                        </th>
                                        <th scope="col" class="border-0">Name</th>
                                        <th scope="col" class="border-0">Date created</th>
                                        <th scope="col" class="border-0">File size</th>
                                        <th scope="col" class="border-0">Action</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @if (files?.Any() == true)
                                    {
                                        @foreach (var file in filteredFiles)
                                        {
                                            <tr>
                                                <td class="ps-4">
                                                    <input type="checkbox" class="form-check-input" @onchange="(e) => ToggleFileSelection(file.Id, e)">
                                                </td>                                <td>
                                    <div class="d-flex align-items-center">
                                        <i class="@GetFileIcon(file.FileName) me-2 text-muted"></i>
                                        <span>@file.FileName</span>
                                    </div>
                                </td>
                                                <td class="text-muted">
                                                    @file.UploadDate.ToString("MMM dd, yyyy, h:mm tt")
                                                </td>
                                                <td class="text-muted">
                                                    @FormatFileSize(file.FileSize)
                                                </td>
                                                <td>
                                                    <button class="btn btn-sm btn-outline-danger" @onclick="() => DeleteFile(file.Id)">
                                                        Delete
                                                    </button>
                                                </td>
                                            </tr>
                                        }
                                    }
                                    else
                                    {                        <tr>
                            <td colspan="5" class="text-center py-5 text-muted">
                                <i class="bi bi-folder2-open display-1 mb-3 d-block"></i>
                                <h5>No files found</h5>
                                <p>Upload your first file to get started</p>
                            </td>
                        </tr>
                                    }
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Pagination Controls -->
                    @if (currentPagingHeader != null && currentPagingHeader.TotalPages > 1)
                    {
                        <div class="card-footer">
                            <div class="d-flex justify-content-between align-items-center">
                                <div class="text-muted">
                                    Showing @((currentPagingHeader.PageNumber - 1) * currentPagingHeader.PageSize + 1) to 
                                    @Math.Min(currentPagingHeader.PageNumber * currentPagingHeader.PageSize, currentPagingHeader.TotalItems) 
                                    of @currentPagingHeader.TotalItems files
                                </div>
                                <nav aria-label="File pagination">
                                    <ul class="pagination pagination-sm mb-0">
                                        <!-- Previous Button -->
                                        <li class="page-item @(currentPagingHeader.PageNumber <= 1 ? "disabled" : "")">
                                            <button class="page-link" @onclick="() => GoToPage(currentPagingHeader.PreviousPage)" disabled="@(currentPagingHeader.PageNumber <= 1)">
                                                Previous
                                            </button>
                                        </li>
                                        
                                        <!-- Page Numbers -->
                                        @for (int i = Math.Max(1, currentPagingHeader.PageNumber - 2); i <= Math.Min(currentPagingHeader.TotalPages, currentPagingHeader.PageNumber + 2); i++)
                                        {
                                            var pageNum = i;
                                            <li class="page-item @(pageNum == currentPagingHeader.PageNumber ? "active" : "")">
                                                <button class="page-link" @onclick="() => GoToPage(pageNum)">@pageNum</button>
                                            </li>
                                        }
                                        
                                        <!-- Next Button -->
                                        <li class="page-item @(currentPagingHeader.PageNumber >= currentPagingHeader.TotalPages ? "disabled" : "")">
                                            <button class="page-link" @onclick="() => GoToPage(currentPagingHeader.NextPage)" disabled="@(currentPagingHeader.PageNumber >= currentPagingHeader.TotalPages)">
                                                Next
                                            </button>
                                        </li>
                                    </ul>
                                </nav>
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    }

    <!-- Upload Progress -->
    @if (isUploading)
    {
        <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 1050;">
            <div class="toast show" role="alert">
                <div class="toast-header">
                    <strong class="me-auto">Uploading File</strong>
                </div>
                <div class="toast-body">
                    <div class="d-flex align-items-center">
                        <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                        <span>@uploadingFileName</span>
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@code {
    private List<UploadResponseDTO> files = new();
    private List<UploadResponseDTO> filteredFiles = new();
    private string searchQuery = string.Empty;
    private bool searchWithAI = false;
    private bool isLoading = true;
    private bool isUploading = false;
    private string uploadingFileName = string.Empty;
    private InputFile? fileInput;
    private HashSet<int> selectedFiles = new();
    
    // Pagination properties
    private PagingParams pagingParams = new() { PageNumber = 1, PageSize = 10 };
    private PagingHeader? currentPagingHeader;

    protected override async Task OnInitializedAsync()
    {
        await LoadFiles();
    }

    private async Task LoadFiles()
    {
        isLoading = true;
        try
        {
            // Update paging params with current search settings
            pagingParams.SearchParams = searchQuery;
            pagingParams.SearchByIA = searchWithAI;
            
            var response = await UploadService.ListUploadedFilesAsync(pagingParams);
            currentPagingHeader = response;
            
            // The Result property contains the actual files list
            if (response?.Result is List<UploadResponseDTO> filesList)
            {
                files = filesList;
                filteredFiles = files.ToList(); // With pagination, we don't need local filtering
            }
            else
            {
                files = new List<UploadResponseDTO>();
                filteredFiles = new List<UploadResponseDTO>();
            }
        }
        catch (Exception)
        {
            // Handle error - could show a toast notification
            files = new List<UploadResponseDTO>();
            filteredFiles = new List<UploadResponseDTO>();
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task ApplySearch()
    {
        // Reset to first page when searching
        pagingParams.PageNumber = 1;
        await LoadFiles();
    }

    private async Task SearchFiles()
    {
        await ApplySearch();
    }

    private async Task OnSearchKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SearchFiles();
        }
    }

    private async Task GoToPage(int pageNumber)
    {
        if (pageNumber >= 1 && pageNumber <= (currentPagingHeader?.TotalPages ?? 1))
        {
            pagingParams.PageNumber = pageNumber;
            await LoadFiles();
        }
    }

    private async Task OnSearchModeChanged()
    {
        // When AI search mode changes, refresh search if there's a query
        if (!string.IsNullOrWhiteSpace(searchQuery))
        {
            await ApplySearch();
        }
    }

    private async Task OpenFileUpload()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", "document.getElementById('fileUploadInput').click()");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening file upload: {ex.Message}");
            // Fallback: try direct element reference
            if (fileInput?.Element != null)
            {
                await JSRuntime.InvokeVoidAsync("eval", "arguments[0].click()", fileInput.Element);
            }
        }
    }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        if (e.File == null) return;

        isUploading = true;
        uploadingFileName = e.File.Name;
        StateHasChanged();

        try
        {
            // Create a wrapper to convert IBrowserFile to IFormFile
            var formFile = new BrowserFileWrapper(e.File);
            
            var request = new UploadRequestDTO
            {
                File = formFile,
                FileName = e.File.Name,
                FileSize = e.File.Size
            };

            var success = await UploadService.UploadFileAsync(request);
            
            if (success)
            {
                await LoadFiles();
                await ShowToast("File uploaded successfully!", "success");
            }
            else
            {
                await ShowToast("Failed to upload file. Please try again.", "error");
            }
        }
        catch (Exception ex)
        {
            await ShowToast($"Error uploading file: {ex.Message}", "error");
        }
        finally
        {
            isUploading = false;
            uploadingFileName = string.Empty;
            StateHasChanged();
        }
    }

    private async Task DeleteFile(int fileId)
    {
        if (await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this file?"))
        {
            try
            {
                // Note: DeleteFileAsync is not implemented yet, so we'll skip this for now
                // await UploadService.DeleteFileAsync(fileId);
                
                // For now, just remove from local list
                files.RemoveAll(f => f.Id == fileId);
                await ApplySearch();
                await ShowToast("File deleted successfully!", "success");
            }
            catch (Exception ex)
            {
                await ShowToast($"Error deleting file: {ex.Message}", "error");
            }
        }
    }

    private void ToggleSelectAll(ChangeEventArgs e)
    {
        if ((bool)e.Value!)
        {
            selectedFiles = filteredFiles.Select(f => f.Id).ToHashSet();
        }
        else
        {
            selectedFiles.Clear();
        }
        StateHasChanged();
    }

    private void ToggleFileSelection(int fileId, ChangeEventArgs e)
    {
        if ((bool)e.Value!)
        {
            selectedFiles.Add(fileId);
        }
        else
        {
            selectedFiles.Remove(fileId);
        }
        StateHasChanged();
    }

    private string GetFileIcon(string fileName)
    {
        var extension = Path.GetExtension(fileName).ToLower();
        return extension switch
        {
            ".pdf" => "bi bi-file-earmark-pdf text-danger",
            ".doc" or ".docx" => "bi bi-file-earmark-word text-primary",
            ".xls" or ".xlsx" => "bi bi-file-earmark-excel text-success",
            ".txt" => "bi bi-file-earmark-text text-secondary",
            ".ppt" or ".pptx" => "bi bi-file-earmark-ppt text-warning",
            ".zip" or ".rar" => "bi bi-file-earmark-zip text-info",
            ".jpg" or ".jpeg" or ".png" or ".gif" => "bi bi-file-earmark-image text-purple",
            _ => "bi bi-file-earmark text-muted"
        };
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private async Task ShowToast(string message, string type)
    {
        // This is a placeholder for toast notifications
        // You can implement a proper toast service later
        await JSRuntime.InvokeVoidAsync("alert", message);
    }
}
